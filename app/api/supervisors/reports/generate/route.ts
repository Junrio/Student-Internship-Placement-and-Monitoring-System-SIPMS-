import { NextRequest, NextResponse } from "next/server"
import { getEvaluationsByEvaluator } from "@/db/queries/evaluations"
import { getInternshipsBySupervisor, getInternshipById } from "@/db/queries/internships"
import { getUserById } from "@/db/queries/users"
import { getCompanyById } from "@/db/queries/companies"

export async function POST(request: NextRequest) {
  try {
    const userId = request.cookies.get("userId")?.value

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    const supervisorId = parseInt(userId, 10)
    if (isNaN(supervisorId)) {
      return NextResponse.json({ error: "Invalid user ID" }, { status: 400 })
    }

    const body = await request.json()
    const { reportType, startDate, endDate, format = "pdf" } = body

    // Get all evaluations by this supervisor
    let evaluations = await getEvaluationsByEvaluator(supervisorId)

    // Filter by date range if provided
    if (startDate && endDate) {
      const start = new Date(startDate)
      const end = new Date(endDate)
      end.setHours(23, 59, 59, 999)

      evaluations = evaluations.filter((evaluation) => {
        const evalDate = new Date(evaluation.evaluationDate)
        return evalDate >= start && evalDate <= end
      })
    }

    // Filter by report type
    if (reportType === "individual") {
      // For individual reports, we'd need an intern ID - for now, return all
      // In a full implementation, you'd add an internId parameter
    }

    // Enrich evaluations with full data
    const enrichedData = await Promise.all(
      evaluations.map(async (evaluation) => {
        const student = await getUserById(evaluation.studentId)
        const internship = await getInternshipById(evaluation.internshipId)
        const company = internship ? await getCompanyById(internship.companyId) : null

        return {
          studentName: student?.name || "Unknown",
          studentId: student?.userId || "N/A",
          company: company?.name || "Unknown",
          position: internship?.position || "Unknown",
          categories: evaluation.categories,
          overallRating: evaluation.overallRating,
          feedback: evaluation.feedback,
          evaluationDate: evaluation.evaluationDate,
        }
      })
    )

    // Generate report content based on format
    if (format === "csv") {
      // Generate CSV
      const headers = [
        "Student Name",
        "Student ID",
        "Company",
        "Position",
        "Punctuality",
        "Communication",
        "Technical Skills",
        "Teamwork",
        "Initiative",
        "Attendance",
        "Overall Rating",
        "Feedback",
        "Evaluation Date",
      ]

      const rows = enrichedData.map((data) => {
        const categoryMap: Record<string, number> = {}
        data.categories.forEach((cat: any) => {
          categoryMap[cat.name] = cat.rating
        })

        return [
          data.studentName,
          data.studentId,
          data.company,
          data.position,
          categoryMap["Punctuality"] || "",
          categoryMap["Communication"] || "",
          categoryMap["Technical Skills"] || "",
          categoryMap["Teamwork"] || "",
          categoryMap["Initiative"] || "",
          categoryMap["Attendance"] || "",
          data.overallRating,
          `"${data.feedback.replace(/"/g, '""')}"`,
          new Date(data.evaluationDate).toLocaleDateString(),
        ]
      })

      const csvContent = [headers.join(","), ...rows.map((row) => row.join(","))].join("\n")
      const csvBlob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" })

      return new NextResponse(csvBlob, {
        headers: {
          "Content-Type": "text/csv;charset=utf-8;",
          "Content-Disposition": `attachment; filename="evaluation-report-${Date.now()}.csv"`,
        },
      })
    } else {
      // Generate PDF (simplified - in production, use a library like pdfkit or jsPDF)
      // For now, return a simple text representation
      const pdfContent = `
EVALUATION REPORT
Generated by SIPMS v1.0
Generated on: ${new Date().toLocaleString()}
Supervisor ID: ${supervisorId}

${enrichedData
  .map(
    (data, index) => `
${index + 1}. ${data.studentName} (${data.studentId})
   Company: ${data.company}
   Position: ${data.position}
   Overall Rating: ${data.overallRating}/5
   
   Category Ratings:
   ${data.categories.map((cat: any) => `   - ${cat.name}: ${cat.rating}/5`).join("\n")}
   
   Feedback: ${data.feedback}
   Date: ${new Date(data.evaluationDate).toLocaleDateString()}
   ${"=".repeat(50)}
`
  )
  .join("\n")}
      `.trim()

      const pdfBlob = new Blob([pdfContent], { type: "application/pdf" })

      return new NextResponse(pdfBlob, {
        headers: {
          "Content-Type": "application/pdf",
          "Content-Disposition": `attachment; filename="evaluation-report-${Date.now()}.pdf"`,
        },
      })
    }
  } catch (error) {
    console.error("Generate report error:", error)
    return NextResponse.json(
      { error: "An error occurred while generating report" },
      { status: 500 }
    )
  }
}





